2018-03-12

### mysql服务器逻辑架构图
![](https://github.com/t734070824/tq.java/blob/master/tq.java.mysql/src/main/java/_high_performance_mysql_3nd/_1_framework_history/1.jpg?raw=true)

### 锁粒度
1. 锁策略:在锁的开销和数据的安全性之间寻求平衡
2. 表锁(table lock):写锁比读锁有更改的优先级, 一个写锁请求可能被插入一个读锁队列之前,反之不行

#### 行锁(row lock)
1. 最大程度的支持并发处理,同时带来最大的锁开销


### 事务

#### 隔离级别(定义了数据库系统中一个操作的结果在何时以何种方式对其他并发操作可见)
1. 未提交读(read uncommitted):事务中的修改,即使没有提交,对其他事务也都是可见的 --> 脏读
2. 提交读(read committed):一个事务开始的时候,只能看到已经提交的事务做的修改, 大多数据库的默认隔离级别(mysql 不是) --> 不可重复读
3. 可重复读(repeatable read):解决了**脏读**的问题, 保证在同一个事务的多次读取同样的记录的结果是一致的.
    - 幻读: 当某个事务正在读取某个范围的记录的时候,其他事务又在该范围插入了新的记录,使之前的事务在读取该范围的记录时,产生幻行
    - 解决: InnoDB 通过对版本并发控制(MVCC, Multiversion Concurrency Control) 解决幻读的问题
    - mysql的事务默认隔离级别
4. 可串行化(serializable):最高的隔离级别, 强制事务串行执行

#### 死锁
1. 多个事务在同一个资源上相互占用, 并请求对方释放占用的资源, 导致恶性循环的情况
2. 解决:
    - 检测到死锁的循环依赖, 返回错误
    - 等待锁的时间超时, 放弃锁请求
    - InnoDB: 将持有最少行级排它锁的事务进行回滚
    
#### 事务日志
1. 记录修改行为
2. 持久到硬盘
3. 顺序IO
4. 数据恢复用

#### Mysql中的事务
1. 默认采用 自动提交        
2. 修改 autocommit对非事务的表, 比如 MyISAM或者是内存表没有任何影响

#### 隐式和显式锁定
1. InnoDB采用的是两阶段锁定协议
2. 在事务执行过程中, 随时都可以执行锁定, 锁只有在执行 commit 或者是 rollback 的时候才会释放
3. InnoDB 也支持通过特定的语句进行显式锁定
    - select ... lock in share more
    - select ... for update

#### mysql中 InnoDB 的MVCC
1. 通过在每行记录后面保存两个隐藏的列来实现的
2. 一个保存行的创建时间, 一个保存行的过期时间(删除时间)     
3. 存储的不是实际的时间值, 而是 **系统版本号**


### InnoDB 概览
1. 采用MVCC支持高并发
2. 实现4个标准的隔离级别, 默认级别是 可重复读

### 