2018-09-19

## 垃圾收集器和内存分配策略

### 概述
1. 哪些内存需要回收
    - 已死的对象
        - 引用计数法
            - 给对象添加一个引用计数器, 一个地方引用它, +1, 引用失效, -1
            - =0的时候不在被使用
            - 优点
                - 实现简单, 判定效率高
            - 缺点
                - 很难解决对象之间相互循环引用的问题
        - 可达性分析算法
            - 通过一些列称为 'GC Roots' 的对象作为起始点, 从这些节点开始向下搜索, 所走过的路径称为引用链
            - 当一个对象到GC Roots没有任何引用链相连时, 则证明对象不可用
            - 可以作为GC Roots的对象
                - **虚拟机栈中引用的对象**
                - **方法区中类静态属性引用的变量**
                - **方法区中常量引用的对象**
                - Native引用的对象
    - 强, 软, 弱, 虚
        - 软:在系统即将发生内存溢出异常之前, 将会把这些对象列进回收范围之中 并进行第二次回收. 如果这次回收还是没有足够的内存
            才会抛出内存溢出异常--> SoftReference
        - 弱:只能生存到下一次垃圾回收发生之前,当发生垃圾回收时候,无论当前内存是否足够,都会回收 **只被** 弱引用关联的对象 --> WeakReference
        - 虚:无法通过一个虚引用获取一个对象实例, 为一个对象设置虚引用关联的唯一目的就是 希望能在这个对象在被收集器回收时收到一个系统通知....
    - finalize()
      - 如果对象 GC Roots不可达, 就会被标记并进行第一次筛选,判断此对象是否有必要调用 finalize()方法(当对象没有覆盖此方法 或者 finalize() 已被虚拟机调用过, 
        就没有必要调用finalize()方法)
      - 如果对象有必要执行 finalize()方法, 对象会被放置在 F-Queue 的队列之中,并在稍后 由一条虚拟机自动建立的,低优先级的 Finalizer线程去执行
        但是并不承诺会等待 finalize 执行完.
      - **防止finalize() 方法执行缓慢,或者 发生了死循环, 导致 F-Queue队列中其他对象永久处于等待状态, 甚至导致整个 内存回收系统 崩溃**
      - 不建议使用: 代价高昂, 不确定性大, 无法保证各个对象的调用顺序

### 垃圾收集算法
1. 标记-清除(Mark-Sweep)
    - 过程
        - 标记阶段
            - 标记处所有需要回收的对象
        - 清除阶段
            - 标记完成后统一回收被标记的对象
    - 不足
        - 效率问题: 标记和清除的两个效率都不高
        - 空间问题: **标记清除后产生大量的碎片, 导致需要分配较大对象的时候, 因为无法找到连续内存而不得不提前出发另一次gc**
2. 复制算法
    - 原因: 解决标记-清除的效率问题
    - 过程
        **- 将可用内存划分为等值的两块**
        - 一次只是用一块
        - 当内存使用完之后, 将存活的对象直接复制到另外一块内存, 清除当前内存
    - 不足
        - **损失一半内存**
    - 优化
        - 新生代朝生夕死, 不需要1:1
        - Eden, To Survivor, From Survivor; 8 : 1 : 1;
        - **分配担保**
3. 标记-整理(Mark-Compact)
    - 解决
        - 复制算法在对象存活率较高的时候需要进行较多的复制操作, 效率会变低
        - 如果不想浪费一半的空间, 就需要额外的空间进行担保, 老年代一般无法直接的选用这种算法
    - 过程
        - 标记阶段
            - 标记处所有需要回收的对象
        - 整理阶段
            - 所有存活的对象向一端移动, 然后清理掉端边界以外的内存
4. 分代收集算法
    - 根据对象存活周期的不同将内存划分为几块
    - 新生代
        - 复制: 少量存活的对象的复制成本就可以完成收集
    - 老年代
        - **对象存活率高, 没有额外空间进行担保**
        - 标记-整理  或  标记清理
        
### HotSpot的算法实现
1. 枚举根节点
    - 要求
        - 对执行的时刻很敏感
        - **要在一个可以确保一致性的快照中进行**
        - STW
        - oopMap
2. 安全点
    - 选择要求
        - 不能太少以致于让GC等待时间太长??
        - 不能过于频繁以致于过分增大运行时的负荷
        - 具有让程序长时间执行的特性
    - 选择
        - 指令序列复用
            - 方法调用
            - 循环跳转
            - 异常跳转
    - 问题: 如何在GC发生时让所有线程**都跑到最近的安全点**上在 停顿下来
        - 抢断式中断(Preemptive Suspension)
            - 不需要线程执行代码的主动配合
            - gc时, 先中断所有线程, 如果发现有线程不在安全点上, 恢复线程跑到安全点
            - 没有虚拟机使用
        - 主动式中断(Voluntary Suspension)
            - gc时, 简单的设置一个标志
            - 各个线程主动去轮询标志, 发现需要中断, 直接挂起
            - **轮询标志的地方和安全点重合** 
3. 安全区域(Safe Region)
    - 问题
        - SafePoint机制保证了程序在运行时, 可以在一个不太长的时间内就会遇到可进入GC的safepoint
        - 那程序在阻塞的时候呢
            - 没有分配CPU时间
            - Sleep
            - Blocked
    - 概念
        - 在一段代码片段中, 引用关系不会发生变化
        - 在这个区域任何地方来是GC都是安全的
        - 看做是被扩展了的Safepoint
    

     