2019-01-22

## 可靠的数据传递

### 可靠性保证
1. 保证分区消息的顺序性
    - 单个分区的写入和读取的顺序性
2. 只有当消息被写入分区的所有同步副本是, 才会被认为 "已提交"
    - 生产者可以选择不同形式的确认
3. 只要还有一个副本是活跃的, **已经提交的消息就不会丢失**
4. 消费者只能读取已经提交的消息

### 复制
1. 同步的副本    
    - 与 zookeeper 有一个活跃的回话
    - 再过去的 Xs 内, 从首领获取过消息
    - 在过去的 Xs 内, 从首领获取过最新的消息
    
### Broker 配置
1. **可以分别控制 broker 以及 主题 的行为**
2. 复制系数
    - 主题: replication.factor
    - broker: default.replication.factor
    - 复制系数 N 至少需要 N个 broker
3. 不完全的首领选举
    - unclear.leader.election
        - 集群范围内
        - 默认 true
    - 是否允许不同步的副本成为首领
    - 允许: 承担数据丢失以及数据不一致的风险
    - 不允许: 较低的可用性, 
4. 最少同步副本   
    - min.insync.replicas
    - **至少存在 N 个同步副本才可以向分区写入数据**
    - **< N 是, 分区将变为 只读**

### 在可靠系统里使用生产者
1. 两个问题
    - acks=1,unclear.leader.election=false,首领挂了, 跟随者副本还没有来得及同步, 并且其他副本仍然认为自己是同步副本
    如果其他副本成为首领, 从生产者的角度, 丢失了消息
    - acks=all, unclear.leader.election=false, 在首领选举期间, 生产者没有很好的处理首领不可用错误, 没有重试消息直到成功
    或造成数据丢失
2. 发送确认
    - acks=0
    - acks=1
    - acks=all
3. 配置生产者重试次数
    - 造成消息重复, 需要消费者做 幂等性
    
### 在可靠的系统中使用消费者
1. 只有被写入所有同步副本的数据才对消费者可用
2. 消费者的可靠配置
    - group.id
    - auto.offset.reset
        - earliest: 分区开始读取数据, 重复数据
        - latest:分区末尾开始读取数据, 错过消息
    - enable.auto.commit
    - auto.commit.interval.ms
        - 提交间隔
3. 显式提交偏移量
    - 总在处理完事件后在提交偏移量
    - 提交频率是性能和重复消息数量之间的权衡
    - 再均衡
    - 消费者重试
    - 消费者可能需要维护状态
    
### 验证系统的可靠性
1. TODO