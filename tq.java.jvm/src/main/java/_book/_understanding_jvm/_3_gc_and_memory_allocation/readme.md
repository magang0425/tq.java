2018-09-19

## 垃圾收集器和内存分配策略

### 概述
1. 哪些内存需要回收
    - 已死的对象
        - 引用计数法
            - 给对象添加一个引用计数器, 一个地方引用它, +1, 引用失效, -1
            - =0的时候不在被使用
            - 优点
                - 实现简单, 判定效率高
            - 缺点
                - 很难解决对象之间相互循环引用的问题
        - 可达性分析算法
            - 通过一些列称为 'GC Roots' 的对象作为起始点, 从这些节点开始向下搜索, 所走过的路径称为引用链
            - 当一个对象到GC Roots没有任何引用链相连时, 则证明对象不可用
            - 可以作为GC Roots的对象
                - **虚拟机栈中引用的对象**
                - **方法区中类静态属性引用的变量**
                - **方法区中常量引用的对象**
                - Native引用的对象
    - 强, 软, 弱, 虚
        - 软:在系统即将发生内存溢出异常之前, 将会把这些对象列进回收范围之中 并进行第二次回收. 如果这次回收还是没有足够的内存
        才会抛出内存溢出异常--> SoftReference
        - 弱:只能生存到下一次垃圾回收发生之前,当发生垃圾回收时候,无论当前内存是否足够,都会回收 **只被** 弱引用关联的对象 --> WeakReference
        - 虚:无法通过一个虚引用获取一个对象实例, 为一个对象设置虚引用关联的唯一目的就是 希望能在这个对象在被收集器回收时收到一个系统通知....
    - finalize()
      - 如果对象 GC Roots不可达, 就会被标记并进行第一次筛选,判断此对象是否有必要调用 finalize()方法(当对象没有覆盖此方法 或者 finalize() 已被虚拟机调用过, 
        就没有必要调用finalize()方法)
      - 如果对象有必要执行 finalize()方法, 对象会被放置在 F-Queue 的队列之中,并在稍后 由一条虚拟机自动建立的,低优先级的 Finalizer线程去执行
        但是并不承诺会等待 finalize 执行完.
      - **防止finalize() 方法执行缓慢,或者 发生了死循环, 导致 F-Queue队列中其他对象永久处于等待状态, 甚至导致整个 内存回收系统 崩溃**
      - 不建议使用: 代价高昂, 不确定性大, 无法保证各个对象的调用顺序

### 垃圾收集算法
1. 