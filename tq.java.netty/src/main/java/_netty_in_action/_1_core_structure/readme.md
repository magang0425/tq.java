2018-01-22
### 核心结构

### BIO NIO
1. BIOApp-->一个连接一个线程
    - 任何时候都会有大量线程处于休眠状态, 等待输入或者是输出数据
    - 分配大量线程
    - 上下文切换的开销

### Netty特性总结
1. 设计???
    - 统一的 API, 支持多种传输类型, 阻塞的 和 非阻塞的???
    - 简单而强大的线程模型???
    - 真正的无连接数据报套接字支持???
    - 链接逻辑组件已支持复用???
2. 健壮性???
    - 不会因为慢速, 快速或者超载的链接而导致 OOM???
    - 消除在高速网络中 NIO 应用程序常见的不公平读/写比率???
    
### 异步和事件驱动
1. 一个即时异步又是时间驱动的系统:
    - **可以 以 任意的顺序响应在任意的时间点产生的事件**

### 核心组件
1. Channel
    - 它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执
      行一个或者多个不同的I/O操作的程序组件） 的开放连接，如读操作和写操作
    - 可以被打开或者被关闭，连接或者断开连接。
2. 回调
    - 就是一个方法, 一个提供给另外的方法调用给的方法的引用
    - 后者可以在合适的时间回调这个引用
3. Future
    - 一种在操作完成通知应用程序的方式
    - **异步操作结果的占位符**
    - **在未来某个时刻完成, 提供对结果的访问**
    - ChannelFuture ChannelFutureListener
        - JDK内置的 Future接口需要手动检查操作是否完成, 或者一直阻塞到完成
        - 由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要
        - //TODO 既然可以主动通知, 还要 Future干什么
            - 应该是添加监听器, 至少有一个通知的地方
4. 事件和 ChannelHandler
    
### 回顾
1. Future, 回调, ChannelHandler
    - 提供一个处理环境, 使应用程序逻辑可以独立于任何网络操作相关的顾虑而 独立的演变 
2. 选择器, 事件, EventLoop
    - 通过触发事件将 Selector 从应用程序中抽象出来，消除了所有本来将需要手动编写
         的派发代码。 在内部，将会为每个 Channel 分配一个 EventLoop， 用以处理所有事件
    - **EventLoop 本身只由一个线程驱动，其处理了一个 Channel 的所有 I/O 事件，并且在该
         EventLoop 的整个生命周期内都不会改变**

