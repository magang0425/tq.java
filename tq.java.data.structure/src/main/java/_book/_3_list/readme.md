2018-08-06

## 列表

### 头,尾节点
1. 头尾节点始终存在, 对外不可见
2. 哨兵节点
3. 哨兵节点的优点
    - 从外部来说, 其前驱和后继都是必然存在的
    - 简化部分算法的实现
    - 是的相关算法不必在对各种边界退化情况做专门的处理
4. 唯一化
    - 自前向后一次处理各个节点P, 通过find()找到在P的前驱中找到雷同者
    - 1+2+3+...+n=n*(1+n)/2 = O(n^2)
5. 有序列表
    - 唯一划
        - 有序列表的雷同节点必然
        - p,q每一对相邻节点
        - O(n)
        
### 排序
1. 插入排序
    - **有序的前缀, 无序的后缀**
    - 通过迭代, 反复的将**后缀的首元素**移动到前缀中
    - 复杂度--O(n^2)
2. 选择排序
    - 无序前缀, 有序后缀
    - 前缀 不大于 后缀
    - 从前缀中找出最大者 并作为最小元素放入后缀的最前面
    - 时间复杂度??? O(n^2)
3. 归并排序
    - 迭代式算法
    - 每一次迭代, 只需要比较两个待归并数据的首元素, 小的取出放入临时数据的靠前位置
    - 该元素的直接后继作为新的首元素
    - 如此往复, 知道某个数据为空, 将另外一个非空的数据直接放入临时数组
    - 以数组{50,10,90,30,70,40,80,60,20}为例
        - 50,10,90,30,70, 
            - 50,10,90
                - 50,10
                    - 10, 50
                - 90
                    - 90
                - 10, 50, 90
            - 30,70
                - 30, 70
            - 10, 30, 50, 70, 90
        - 40,80,60,20
            - ....
            - 20, 40, 60, 80
        - 10, 20, 30, 40, 50, 60, 70, 80, 90
    - //TODO 时间复杂度的求解 O(nlongn)
            
      
      
      

        