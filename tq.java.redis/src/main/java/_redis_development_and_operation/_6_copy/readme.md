2018-05-08

## 复制

### 建立复制
1. 一个从节点只能有一个主节点
2. 一个主节点可以同时具有多个从节点
3. 复制的节点是单向的 主-->从
4. **从节点配置 slaveof masterHost masterPort**


### 断开复制
1. slaveof no one
    - 断开与主节点的复制关系
    - 从节点晋升为 主节点
2. 切换主节点-- slaveof newHost newPort
    - 断开与旧主节点的复制关系
    - 与新节点建立复制关系
    - **删除从节点的当前所有数据**
    - 最新主节点进行复制操作
3. Q:
    - **如果当前节点就是主节点, 如果成为从节点是否删除当前数据**
    - **是的**

### 传输延时
1. 主从节点一般部署在不同机器上， 复制时的网络延迟就成为需要考虑的
   问题， Redis为我们提供了repl-disable-tcp-nodelay参数用于控制是否关闭
   TCP_NODELAY， 默认关闭
   - 当关闭时， 主节点产生的命令数据无论大小都会及时地发送给从节
     点， 这样主从之间延迟会变小， 但增加了网络带宽的消耗。 适用于主从之间
     的网络环境良好的场景， 如同机架或同机房部署
   - 当开启时， 主节点会合并较小的TCP数据包从而节省带宽。 默认发送
     时间间隔取决于Linux的内核， 一般默认为40毫秒。 这种配置节省了带宽但
     增大主从之间的延迟。 适用于主从网络环境复杂或带宽紧张的场景， 如跨机
     房部署
2. 部署主从节点时需要考虑网络延迟、 带宽使用率、 防灾级别等因素， 如
   要求低延迟时， 建议同机架或同机房部署并关闭repl-disable-tcp-nodelay； 如
   果考虑高容灾性， 可以同城跨机房部署并开启repl-disable-tcp-nodelay
   
### 拓扑
1. 一主一从
    - 当应用写命令并发量较高且需要持久化时， 可以只在从节点上开启AOF
    - **当主节点关闭持久化功能时，
      如果主节点脱机要避免自动重启操作。 因为主节点之前没有开启持久化功能
      自动重启后数据集为空， 这时从节点如果继续复制主节点会导致从节点数据
      也被清空的情况， 丧失了持久化的意义**
    - 安全做法: 从节点 slaveof no one
2. 一主多从
    - 读写分离
    - 读命令发送到从节点执行
    - 缺点:
        - 高并发的时候, 多个从节点导致主节点的写命令多次发送, 消耗带宽
        - 加重 主节点的不稳定性
3. 树状主从结构
    - 从节点作为其他节点的主节点, 继续向下层复制
    - 降低对主节点的干扰
    
    
### 原理
1. 复制过程
    - 保存主节点信息
    - 主从建立 socket 连接
    - 发送 ping  命令(pong) 
    - 权限验证
    - 同步数据集
        - psync
        - 全量同步以及 部分同步
    - 命令持续复制
2. 数据同步
    - 全量复制
    - 部分复制: 主节点补发丢失数据给从节点
    - psync
        - 主从节点各自复制偏移量
            - 主节点在处理写入命令后, 会把命令的自身长度做累加记录
            - 可以通过主节点的统计信息, 计算出 master_repl_offset - slave0:offset
            - 但是 主节点的   slave0:offset 与 从节点 slave_repl_offset 不一致???
                - 两个offset一直在改变...
        - 主节点复制积压缓冲区
            - 保存在主节点的一个固定长度的队列, 默认大小为 1MB, 当主节点有连接的从节点(slave) 时被创建, 
            - 主节点响应写请求的时候, 不仅会把命令发送从节点, 还会写入复制挤压缓冲区
            - 用于部分复制 以及 复制命令丢失的数据补救
        - 主节点运行id
            - 动态分配的一个40位的十六进制字符串作为运行ID
            - 唯一识别一个 Redis节点
            - 主节点的运行id变化之后会做全量复制
            - **关闭启动后, run ID会改变的**
        - psync 命令
            - psync runID(复制主节点的id) offset(从节点已复制的数据偏移量)
            - master--> slave
                - 1:+FULLRESYNC-->全量复制
                - 2:+CONTINUE-->部分复制
                - 3:-ERR-->主节点版本低于 2.8, 
                
3. 全量同步失败
    - 同步超大RDB文件
        - 分析 Full resync 和 Master<->Slave 两行日志的时间差, 可以计算出文件的传输时间
        - 总时间超过 repl-timeout 所配置的值(默认60s), 从节点将放弃接受RDB文件, 并清理已下载的临时文件, 导致全量复制失败
        - 减少数据量大的节点的数据同步
        - 增加 repl-timeout 的配置值
    - 高流量写入造成主节点复制客户端缓冲区溢出
        - 主节点在从节点接受RDB文件期间 依然接受客户端请求, 这个期间的写命令保存在复制客户端缓冲区中
        - client-output-buffer-limit slave 256MB 64Mb 60
        - 如果60秒内缓冲区消耗持续大于64MB或者直接超过256MB时， 主节点将直接关闭复制客户端连接， 造成全量同步失败
        - redis.conf
            - client-output-buffer-limit normal 0 0 0
            - client-output-buffer-limit slave 256mb 64mb 60
            - client-output-buffer-limit pubsub 32mb 8mb 60
    
3. 全量复制
    - psync 全量复制
    - 时间开销
        - 主节点的bgsave时间
        - RDB数据网络传输时间
        - 从节点清空数据的时间
        - 从节点加载RDB时间
        - 可能的AOF重写时间
    - ![](https://github.com/t734070824/tq.java/blob/master/tq.java.redis/src/main/java/_redis_development_and_operation/_6_copy/1.jpg?raw=true)
    

4. 复制积压缓冲区
    - //TODO
    
4. 主从心跳判断机制
    
    
5. 异步复制
    - 主节点处理完写命令后直接返回客户端
    - 异步发送写命令到 从节点, 从节点完成复制操作
    
    
    