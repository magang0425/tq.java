2018-04-30

## 小功能大用处

### 慢查询
1. 预设阀值:slowlog-log-slower-than
    - 如果slowlog-log-slower-than=0会记录所有的命令， slowlog-log-slowerthan<0对于任何命令都不会进行记录
2. 慢查询记录: slowlog-max-len
    - 使用了一个列表来存储慢查询日 志， slowlog-max-len就是列表的最大长度。 一个新的命令满足慢查询条件时
      被插入到这个列表中， 当慢查询日志列表已处于其最大长度时， 最早插入的一个命令将从列表中移出
3. **慢查询只记录命令执行时间， 并不包括命令排队和网络传输时间**

### redis shell
1.

### Pipeline机制
1. **它能将一组Redis命令进行组装， 通过一次RTT传输给Redis， 再将这组Redis命令的执行结果按顺序返回给客户端**
2. Redis命令真正执行的时间通常在微秒级别， 所以才会有Redis性能瓶颈是网络这样的说法
3. 原生批量命令与Pipeline对比
    - 原生批量命令是原子的， Pipeline是非原子的。
    - 原生批量命令是一个命令对应多个key， Pipeline支持多个命令。
    - 原生批量命令是Redis服务端支持实现的， 而Pipeline需要服务端和客户
      端的共同实现。
      
### 事务 与 Lua
1. Redis 不支持回滚      
      
      
### Bitmaps
1. 本身不是数据结构, 是一个字符串, 但可以对字符串进行 位操作(字符串 --> ASCII --> 二进制)      
2. 单独提供一套指令, 
3. 相当于位 操作

### Bitmap 分析
1. 做活跃用户分析:
    - 一亿用户, 5千万活跃
        - 就是一亿位 的二进制, 内存占用: 1位 * 1亿 = 12.5MB
        - 集合类型 64位 * 5千万 = 400MB
    - 如果是少量活跃 10w
        - 用 Bitmap就会浪费 内存占用: 1位 * 1亿 = 12.5MB
        - 集合: 64位 * 10w = 800KB
      
### 发布与订阅
1. 

### 回顾
1. 慢查询中的两个重要参数slowlog-log-slower-than和slowlog-maxlen。
2. 慢查询不包含命令网络传输和排队时间。
4. **Pipeline可以有效减少RTT次数， 但每次Pipeline的命令数量不能无节制。**
5. Redis可以使用Lua脚本创造出原子、 高效、 自定义命令组合。
6. Redis执行Lua脚本有两种方法： eval和evalsha。
7. **Bitmaps可以用来做独立用户统计， 有效节省内存**。
8. **Bitmaps中setbit一个大的偏移量， 由于申请大量内存会导致阻塞。**
9. Redis的发布订阅机制相比许多专业的消息队列系统功能较弱， 不
   具备堆积和回溯消息的能力， 但胜在足够简单      