2018-02-06

### 相同的类 
1. Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。
只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，
也是不同的

### 类加载器与 Web 容器
1. 以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例
2. 该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，
如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的
3. 这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全


### 线程上下文类加载器
1. SPI 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，
因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。
也就是说，类加载器的代理模式无法解决这个问题
2. 使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类
3. 通过线程上下文来加载第三方库jndi实现，而不依赖于双亲委派。
大部分java application服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。
还有一些采用hot swap特性的框架，也使用了线程上下文类加载器

### hot swap(热插拔)
1. 这里表示一个类已经被一个加载器加载了以后，在不卸载它的情况下重新再加载它一次
2. Java缺省的加载器对相同全名的类只会加载一次，以后直接从缓存中取这个Class object
3. 因此要实现hot swap，必须在加载的那一刻进行拦截，先判断是否已经加载，若是则重新加载一次，否则直接首次加载它
4. http://blog.csdn.net/zhoudaxia/article/details/35897057