2018-05-07

## 问题定位于优化

### fork耗时问题定位
1. fork创建的子进程不需要拷贝父进程的物理内存空间， 但是会复制父进程的空间内存页
   表。 
2. 例如对于10GB的Redis进程， 需要复制大约20MB的内存页表， 因此fork
   操作耗时跟进程总内存量息息相关
3. 改善建议:
    - 优先使用物理机或者高效支持fork操作的虚拟化技术， 避免使用
      Xen ???
    - 控制Redis实例最大可用内存， fork耗时跟内存量成正比， 线上建议
      每个Redis实例内存控制在10GB以内 
    - 合理配置Linux内存分配策略， 避免物理内存不足导致fork失败
    - 降低fork操作的频率， 如适度放宽AOF自动触发时机， 避免不必要
      的全量复制等

### 子进程开销监控和优化
1. cpu
    - CPU开销分析。 子进程负责把进程内的数据分批写入文件， 这个过程
    属于CPU密集操作， 通常子进程对单核CPU利用率接近90%.
    - CPU消耗优化。 Redis是CPU密集型服务， 不要做绑定单核CPU操作。
    由于子进程非常消耗CPU， 会和父进程产生单核资源竞争。
    - 不要和其他CPU密集型服务部署在一起， 造成CPU过度竞争。
    - 如果部署多个Redis实例， 尽量保证同一时刻只有一个子进程执行重写
    工作
2. 内存
    - 内存消耗分析。 子进程通过fork操作产生， 占用内存大小等同于父进
      程， 理论上需要两倍的内存来完成持久化操作， 但Linux有写时复制机制
      （copy-on-write） 。 父子进程会共享相同的物理内存页， 当父进程处理写请
      求时会把要修改的页创建副本， 而子进程在fork操作过程中共享整个父进程
      内存快照
    - 避免在大量写入时做子进程重写操作， 这样将导致父进程维护大量
      页副本， 造成内存消耗
3. 硬盘
    - 硬盘开销分析。 子进程主要职责是把AOF或者RDB文件写入硬盘持久
      化。 势必造成硬盘写入压力。 根据Redis重写AOF/RDB的数据量， 结合系统
      工具如sar、 iostat、 iotop等， 可分析出重写期间硬盘负载情况。
    - 不要和其他高硬盘负载的服务部署在一起。 如： 存储服务、 消息队
      列服务等
    - AOF重写时会消耗大量硬盘IO， 可以开启配置no-appendfsync-onrewrite， 默认关闭。 表示在AOF重写期间不做fsync操作
    - 当开启AOF功能的Redis用于高流量写入场景时， 如果使用普通机械
      磁盘， 写入吞吐一般在100MB/s左右， 这时Redis实例的瓶颈主要在AOF同步
      硬盘上
    - 对于单机配置多个Redis实例的情况， 可以配置不同实例分盘存储
      AOF文件， 分摊硬盘写入压力


### AOF追加阻塞
![](https://github.com/t734070824/tq.java/blob/master/tq.java.redis/src/main/java/_redis_development_and_operation/_5_persistence/6.jpg?raw=true)

1. 流程分析
    - 主线程负责写入 AOF 缓冲区
    - AOF线程负责每秒执行一次同步磁盘操作, 并记录最近一次同步的时间
    - 主线程负责对比上一次AOF同步时间
        - 如果距上次同步成功时间在2秒内， 主线程直接返回
        - 如果距上次同步成功时间超过2秒， 主线程将会阻塞， 直到同步操作完
          成
2. 问题分析
    - **everysec配置最多可能丢失2秒的数据, 不是1秒**
    - **如果系统的 fsync 缓慢, 将会导致Redis主线程阻塞影响效率**
3. 定位
    - 发生AOF阻塞时， Redis输出日志， 用于记录AOF fsync阻塞导致
      拖慢Redis服务的行为
    - 每当发生AOF追加阻塞事件发生时， 在info Persistence统计中，
      **aof_delayed_fsync指标会累加**， 查看这个指标方便定位AOF阻塞问题
    - AOF同步最多允许2秒的延迟， 当延迟发生时说明硬盘存在高负载问
      题， 可以通过监控工具如iotop， 定位消耗硬盘IO资源的进程
      
### 多实例部署
1. 充分利用CPU多核特性, 在一台机器部署多个Redis实例
2. 但是 同一时刻运行多个子进程, 对系统影响较为明显
    - 外部程序轮询控制AOF重写操作的执行
        - 轮询机器上的所有redis
        - 确认aof增长率
        - 超过阈值, bgrewriteaof 手动触发当前redis实例的AOF重写
        - 运行期间循环检查aof_rewrite_in_progress和
          aof_current_rewrite_time_sec指标， 直到AOF重写结束
        - 循环
        