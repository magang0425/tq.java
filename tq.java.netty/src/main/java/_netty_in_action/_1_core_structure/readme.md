2018-01-22
### 核心结构

### BIO NIO
1. BIOApp-->一个连接一个线程
    - 任何时候都会有大量线程处于休眠状态, 等待输入或者是输出数据
    - 分配大量线程
    - 上下文切换的开销

### Netty特性总结
1. 设计???
    - 统一的 API, 支持多种传输类型, 阻塞的 和 非阻塞的???
    - 简单而强大的线程模型???
    - 真正的无连接数据报套接字支持???
    - 链接逻辑组件已支持复用???
2. 健壮性???
    - 不会因为慢速, 快速或者超载的链接而导致 OOM???
    - 消除在高速网络中 NIO 应用程序常见的不公平读/写比率???
    
### 异步和事件驱动
1. 一个既是异步又是时间驱动的系统:
    - **可以 以 任意的顺序响应在任意的时间点产生的事件**

### 核心组件
1. Channel
    - 它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执
      行一个或者多个不同的I/O操作的程序组件） 的开放连接，如读操作和写操作
    - 可以被打开或者被关闭，连接或者断开连接。
2. 回调
    - 就是一个方法, 一个提供给另外的方法调用给的方法的引用
    - 后者可以在合适的时间回调这个引用
3. Future
    - 一种在操作完成通知应用程序的方式
    - **异步操作结果的占位符**
    - **在未来某个时刻完成, 提供对结果的访问**
    - ChannelFuture ChannelFutureListener
        - JDK内置的 Future接口需要手动检查操作是否完成, 或者一直阻塞到完成
        - 由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要
        - ChannelFutureListener 可以看做回调的一个更加精细的版本
            - 回调和Future
4. 事件和 ChannelHandler
    - 已经发生的事来触发适当的动作
    - 网络相关
        - 入站数据或者相关的状态更改而触发的事件
            - 连接已被激活或者连接失活
            - 数据读取
            - 用户事件
            - 错误事件
        - 出站事件是未来将会触发的某个动作的操作结果
            - 打开或者关闭到远程节点的连接；
            - 将数据写到或者冲刷到套接字。

    
### 回顾
1. Future, 回调, ChannelHandler
    - 事件被派发到 ChannelHandler 的方法发生在更深的层次
    - 提供一个处理环境, 使应用程序逻辑可以独立于任何网络操作相关的顾虑而 独立的演变 
2. 选择器, 事件, EventLoop
    - 通过触发事件将 Selector 从应用程序中抽象出来，消除了所有本来将需要手动编写
         的派发代码。 在内部，将会为每个 Channel 分配一个 EventLoop， 用以处理所有事件
    - **EventLoop 本身只由一个线程驱动，其处理了一个 Channel 的所有 I/O 事件，并且在该
         EventLoop 的整个生命周期内都不会改变**
    - 多个 Channel 共享一个 线程

