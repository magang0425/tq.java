2018-05-14

## 缓存设计


### 缓存的收益与成本(client--cache--db)
1. 收益
    - 加速读写
    - 降低后端负载
2. 成本
    - 数据不一致: 缓存层与存储层存在一定时间窗口的不一致 
    - 代码维护成本
    - 运维成本
3. 使用场景
    - 开销大的操作
    - 加速响应相求
    
### 缓存更新策略
1. LRU/LFU/FIFO 算法剔除
    - 一致性: 只能决定那种算法, 一致性较差
    - 维护成本: 只需要配置最大 maxmemory和对应的策略即可
2. 超时剔除
    - 一致性: 一段时间内不一致
    - 维护成本: 成本不高, 数据应用方允许这段时间的缓存不一致
3. 主动更新
    - 使用场景: 对于数据的一致性要求高, 需要在真实数据更新后, 立即更新缓存数据--利用消息系统或者其他方式通知缓存更新
    - 一致性: 最高, 但**是主动更新发生问题, 这条数据可能长时间不更新, 配合 超时剔除 效果更好**
    - 维护成本: 较高, 需要自己维护
4. 实践
    - 低一致性业务配置 最大内存和淘汰策略
    - 高一致性使用 超时删除和主动更新结合的方式
    
### 缓存粒度
1. 缓存粒度问题是一个容易被忽视的问题， 如果使用不当， 可能会造成很
   多无用空间的浪费， 网络带宽的浪费， 代码通用性较差等情况， 需要综合数
   据**通用性、 空间占用比、 代码维护性**三点进行取舍
   
### 缓存穿透优化
1. 概念: 查询一个根本不存在的数据, 缓存层和存储层都不命中, 出于容错的考虑, 从存储层查不到就不写入缓存层
2. 影响: 导致不存在的数据每次请求都要到存储层去查询, 失去了缓存保护后端的意义
3. 解决:
    - 缓存空对象
        - 缓存空值, 需要更多的内存空间
        - 缓存层与存储层会有一段时间数据不一致: 利用消息系统或者其他方式清楚掉缓存中的空值
    - 布隆过滤器拦截
        - https://blog.csdn.net/tianyaleixiaowu/article/details/74721877
        - 应用场景
            - 数据命中不高
            - 数据相对稳定
            - 实时性第(数据集大)
            - 代码维护复杂

### 雪崩优化
1. 概念: 由于缓存层承载着大量请求， 有效地
       保护了存储层， 但是如果缓存层由于某些原因不能提供服务， 于是所有的请
       求都会达到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情
       况
2. 解决:
    - 保证缓存层服务高可用
    - 依赖隔离组件为厚点限流并降级: **Hystrix**
    - 提前演练...

### 热点key重建优化(多线程同时重建)
1. 互斥锁: 
    - 简单
    - 较好降低后端负载, 一致性上比较好
    - 如果重建缓存时间较长, 存在死锁或者是线程池阻塞的风险
2. 永不过期
    - 数据不一致的情况
    - 代码复杂度上升