2017-11-21
	1.synchronized
		1)原子性
		2)内存可见性:当对象获取锁时，它首先使自己的高速缓存无效，这样就可以保证直接从主内存中装入变量。
		 同样，在对象释放锁之前，它会刷新其高速缓存，强制使已做的任何更改都出现在主内存中。
		  这样，会保证在同一个锁上同步的两个线程看到在 synchronized 块内修改的变量的相同值
		  
		3)volatile只保证可见性，不保证原子性！**
		
	2.synchronized 的缺点
		1)无法中断一个正在等候获得锁的线程
		2)无法通过投票获得锁
		3)同步还要求锁的释放只能在与获得锁所在的堆栈帧相同的堆栈帧中进行，多数情况下，
		这没问题（而且与异常处理交互得很好），但是，确实存在一些非块结构的锁定更合适的情况。
		

2017-12-22
    3.锁粒度细化
        1)很多时候我们会将实例的方法加 synchronized 关键字来达到数据同步的效果,但此时是需要获得这个对象的锁才可以操作被锁的方法,如果只想修改这个实例的某个字段的时候
        锁住整个对象就有些浪费了,通过将对象中需要同步的变量每一个分配一个锁,到达锁粒度细化的目标
        2)