2018-03-17

### 索引基础
1. 全值匹配:和索引中所有的列进行匹配
2. 匹配最左前缀: 只是用索引的第一列
3. 匹配列前缀: 只匹配某一列的值得开头部分, 也只是使用索引的第一列
4. 匹配范围值:可用于查找姓在 Aillen 和 Braay 之间的人, 也只是使用索引的第一列;
5. 精确匹配某一列并范围匹配另外一列
6. 只访问索引的查询:覆盖索引

### B-Tree 索引的限制
1. 如果不是按照索引的最左列开始查找, 则无法使用索引
2. 不能跳过索引中国的列 (参考第一条)
3. 如果查询中有某个列的范围查询(eg:like) ,则右边所有的列都无法使用索引优化

### 哈希索引
1. 哈希索引基于哈希表实现, 只有精确匹配索引所有列的查询才有效
2. 哈希索引只有Memory, NDB两种引擎支持，Memory引擎默认支持哈希索引，如果多个hash值相同，出现哈希碰撞，那么索引以链表方式存储
3. 要使InnoDB或MyISAM支持哈希索引，可以通过伪哈希索引来实现，叫自适应哈希索引。

### 哈希索引的限制
1. **哈希索引只包含 哈希值 和 行指针, 不存储字段值**, 不能使用索引中的值来避免读取行
2. 不是按照索引值顺序存储, 无法用于排序
3. 不支持部分索引查找
4. 只支持等值比较查询 (eg: =, IN, <=>)
5. 哈希冲突很多的话, 对索引的维护代价很高:当从表中删除一行,存储引擎需要遍历对应哈希值得链表中的每一行,找到并删除对应引用.

### 自适应哈希索引
1. 它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”（详见《MySQL - 浅谈InnoDB体系架构》中内存构造）建立哈希索引
2. 之所以该技术称为“自适应”是因为完全由InnoDB自己决定，不需要DBA人为干预。它是通过缓冲池中的B+树构造而来，且不需要对整个表建立哈希索引，因此它的数据非常快

### 伪哈希索引
1. 

### 索引的优点
1. 减少服务器需要扫描的数据量
2. 避免排序和临时表
3. 将随机I/O 变为 顺序 I/O


### 索引策略

#### 独立的列
1. 索引列不能是表达式的一部分, 也不能使函数的参数

#### 前缀索引以及索引选择性
1. 选择足够长的前缀已保证较高的选择性, 同时永不能太长(节约空间)
2. 为了决定前缀的合适长度, 需要找到最常见的值得列表, 然后和最常见的前缀进行比较

#### 多列索引
1. 

#### 选择合适的索引列顺序
1. 

### 聚簇索引
1. 对磁盘上实际数据重新组织以按指定的一个或多个列的值排序的算法。特点是存储数据的顺序和索引顺序一致
2. 一般情况下主键会默认创建聚簇索引，且一张表只允许存在一个聚簇索引
3. 在 InnoDB 中, 聚簇索引 "就是" 表

### 聚簇索引的优点
1. 把相关的数据保存在一起
2. 数据访问更快
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

### 聚簇索引的缺点
1. 最大限度的提高了IO密集型应用的性能, 但是如果数据全部都放在内存中, 优势就不能明显了
2. 插入速度依赖于 插入排序
3. 更新聚簇索引列的代价更高, 强制 InnoDB 将每一个被更新的列移动到新的位置
4. 在插入新行 或者是 主键被更新需要移动行的时候, 可能面临 "页分裂" 的问题,

### 二级索引
1. mysql中每个表都有一个聚簇索引（clustered index ），除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）
2. 以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。如果你不定义为您的
表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。如果没有这样的列，
InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引
1. 二级索引叶子节点保存的不是指向行的物理地址, 而是行的主键值
2. 通过二级索引查找行, 需要存储引擎找到二级索引的叶子节点获取对应的主键值, 然后根据这个主键值去聚簇索引中查找对应的行

### 顺序的主键什么时候会造成更坏的结果
1. 主键的上界 会成为 "热点", 并发插入导致 间隙锁
2. AUTO_INCREMENT 锁机制


### 覆盖索引
1. 覆盖索引必须存储索引列的值, 而哈希索引,空间索引和全文索引等都不存储索引的值, 所以Mysql只能使用 B-Tree 索引做覆盖索引
2. 

### 总结:
1. 尽可能选择合适的索引以避免单行查找
2. 使用数据原生顺序从而避免额外的排序操作
3. 使用索引覆盖查询