2018-02-06

### 相同的类 
1. Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。
只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，
也是不同的

### 类加载器与 Web 容器
1. 以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例
2. 该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，
如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的
3. 这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全


### 双亲委派模型的破坏者-线程上下文类加载器
1. SPI(Service Provider Interface) 实现的 Java 类一般是由系统类加载器来加载的。引导类加载器是无法找到 SPI 的实现类的，
因为它只加载 Java 的核心库。它也不能代理给系统类加载器，因为它是系统类加载器的祖先类加载器。
也就是说，类加载器的代理模式无法解决这个问题
2. **这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，
如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，
那这个类加载器默认就是应用程序类加载器（Application ClassLoader）**
2. 使用线程上下文类加载器，可以在执行线程中抛弃双亲委派加载链模式，使用线程上下文里的类加载器加载类
3. 通过线程上下文来加载第三方库jndi实现，而不依赖于双亲委派。
大部分java application服务器(jboss, tomcat..)也是采用contextClassLoader来处理web服务。
还有一些采用hot swap特性的框架，也使用了线程上下文类加载器

### hot swap(热插拔)
1. 这里表示一个类已经被一个加载器加载了以后，在不卸载它的情况下重新再加载它一次
2. Java缺省的加载器对相同全名的类只会加载一次，以后直接从缓存中取这个Class object
3. 因此要实现hot swap，必须在加载的那一刻进行拦截，先判断是否已经加载，若是则重新加载一次，否则直接首次加载它
4. http://blog.csdn.net/zhoudaxia/article/details/35897057
5. **加载指定的class文件,直接调用findClass(),绕过检测机制，创建不同class对象**

### java 的 classloader
1. 引导类加载器(bootstrap class loader)
    - 引导启动 JVM
    - 载入运行 JVM 所需要的类, 以及所有的核心类: java.lang.*, java.io.*等
    - 负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等
2. 扩展类加载器(extension class loader)    
    - 载入标准扩展中的类
    - 有利于程序开发, 只需要将jar文件复制到扩展目录中就可以被类加载器搜索到
    - 负责加载Java的扩展类库，默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。
3. 系统类加载器(system class loader)    
    - 默认的类加载器
    - 负责加载应用程序classpath目录下的所有jar和class文件。

### 类加载器与Web容器
1. 对于运行在 Java EE™容器中的 Web 应用来说，类加载器的实现方式与一般的 Java 应用有所不同。
2. 不同的 Web 容器的实现方式也会有所不同。以 Apache Tomcat 来说，每个Web 应用都有一个对应的类加载器实例。
3. **该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。**
4. 这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，
    - 其目的是使得Web 应用自己的类的优先级高于 Web 容器提供的类。
    - 这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。

    
   