2019-01-16

## 消费者

### 消费者和消费群组
1. Kafka 消费者从属与消费者群组, 
2. 一个群组里的消费者订阅的是同一个主题
3. **每个消费者接收主题一部分分区的消息**
    - 如果群组中的消费者数量超过了主题的分区数量, 就有一部分消费者会被闲置
4. 多个应用程序从同一个主题读取数据
    - 只要每个应用程序有自己的消费群组, 就可以让他们获取到主题的所有消息
    
### 消费者群组和分区再均衡
1. 再均衡
    - 分区的所有权从一个消费者注意到另外一个消费者
    - 比如
        - 新的消费者加入群组
        - 一个消费者关闭或者崩溃后, 离开群组
        - 主题的分区数发生变化
    - 高可用和可伸缩性
    - 期间, 消费者无法读取消息
2. 群组协调器
    - 消费者通过向 被指派为群组1协调器的 broker (不同的群组可以有不同的协调器) 发送心跳来维持他们和群组的从属关系, 以及他们对分区的所有权关系

### 分配分区的过程
1. 消费者加入群组是, 会向群组协调器发送一个 JoinGroup 请求, 
2. 第一个加入群组的消费者成为 群主
3. 群主从协调器获取群组的成员列表, 负责为每一个消费者分配分区
    - 实现 org.apache.kafka.clients.consumer.internals.PartitionAssignor
4. **这个过程在 每次再均衡给的时候重复发生**

### 创建消费者
1. group.id
    - 消费者所属群组的名字
    
### 订阅主题
1. 可以使用 正则表达式 来订阅多个主题
    - 当可以订阅新的主题的时候, 会触发再均衡

### 轮询
1. 消费轮询是消费者API的核心, 通过简单的轮询向服务器请求数据
2. 一旦消费者订阅了主题, 轮询会处理所有的细节
    - 群组协调, 分区再均衡, 发送心跳, 获取数据
3. 代码
    - 是一个无限循环
    - poll(timeout) 
4. poll
    - 第一次调用新消费者的 poll() 方法时, 负责查找 GroupCoordinator(协调者), 加入群组, 接受分配的分区 
    - 在同一个群组里, 无法再一个线程中运行多个消费者, 也无法让多个线程安全的共享一个消费者
    
### 消费者配置
1. TODO

### 提交和偏移量
1. 每次调用 poll, 总是返回生产者写入 kafka 但还没有被消费者读取过的记录
    - 可以追踪哪些记录是被群组的那个消费者读取的
2. 提交
    - 更新分区当前位置的操作
    - 消费者往一个叫做 _consumer_offset 的特殊主题发送消息, 包含每个分区的偏移量
    - 如果触发 再均衡后, 每个消费者可能分配到新的分区, 不再是之前处理的那个
    - 为了能够继续工作, 消费者需要读取每个分区最后一次提交的偏移量
    - **如果提交的偏移量小于客户端处理的最后一条消息的偏移量, 处理两个偏移量之间的消息就会被重复消费**